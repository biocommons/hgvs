#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import absolute_import, division, print_function, unicode_literals

"""demonstrate mapping from ENST variants to NM variants

Mapping from ENST to NMs is frought with corner cases. This
experimental script is an example of one way to do it.

"""

import collections
import logging
import re
import sys

import ometa.runtime

import hgvs.dataproviders.uta
import hgvs.exceptions
import hgvs.parser
import hgvs.projector
import hgvs.validator
import hgvs.variantmapper

from hgvs.decorators.lru_cache import lru_cache
from hgvs.utils.accessions import primary_assembly_accessions


primary_assembly = 'GRCh37'
src_alt_aln_method = 'genebuild'
dst_alt_aln_method = 'splign'


class Transformer(object):
    """Projects variants from ENST transcripts to RefSeq transcripts"""

    def __init__(self, hdp,
                 primary_assembly='GRCh37',
                 src_alt_aln_method='genebuild',
                 dst_alt_aln_method='splign',
                 similarity='exon structure'):
        self.hdp = hdp
        self.primary_assembly = primary_assembly
        self.primary_assembly_accessions = set(primary_assembly_accessions[primary_assembly])
        self.src_alt_aln_method = src_alt_aln_method
        self.dst_alt_aln_method = dst_alt_aln_method
        self.similarity = similarity
    

    def project_variant(self,var_c):
        """Given a single ENST c. variant, return a *list* of variants on
        RefSeqs.
        """

        assert var_c.ac.startswith('ENST'), "expected an ENST variant ("+str(var_c)+")"
        assert var_c.type == 'c', "expected a transcript variant ("+str(var_c)+")"

        alt_ac = self._alt_ac_for_tx_ac(var_c.ac)
        nm_acs = self._get_enst_nm_equivs(var_c.ac,alt_ac)
        pjs = [ self._fetch_Projector(var_c.ac,nm_ac,alt_ac) for nm_ac in nm_acs ]
        return [ pj.project_variant_forward(var_c) for pj in pjs ]


    @lru_cache(maxsize=100)
    def _fetch_Projector(self,src_ac,dst_ac,alt_ac):
        return hgvs.projector.Projector(self.hdp,
                                        alt_ac, src_ac, dst_ac,
                                        src_alt_aln_method=self.src_alt_aln_method,
                                        dst_alt_aln_method=self.dst_alt_aln_method)


    @lru_cache(maxsize=200)
    def _get_enst_nm_equivs(self,enst_ac,alt_ac):
        """return NMs that are "similar" to enst_ac"""
        q = """
            select E.tx_ac as enst_ac,N.tx_ac as refseq_ac
            from tx_aln_summary_mv E
            join tx_aln_summary_mv N on E.es_fingerprint=N.es_fingerprint
            where E.alt_aln_method='genebuild' and N.alt_aln_method='splign'
            and E.tx_ac=%s and E.alt_ac=%s
            """
        cur = self.hdp._get_cursor()
        cur.execute(q,[enst_ac,alt_ac])
        return [ r['refseq_ac'] for r in cur.fetchall() ]


    @lru_cache()
    def _alt_ac_for_tx_ac(self,tx_ac):
        """return chromosomal accession for given transcript accession (and
        the primary_assembly and aln_method setting used to
        instantiate this EasyVariantMapper)

        """
        alt_acs = [e['alt_ac'] 
                   for e in  self.hdp.get_tx_mapping_options(tx_ac)
                   if e['alt_aln_method'] == self.src_alt_aln_method
                   and e['alt_ac'] in self.primary_assembly_accessions]
        if len(alt_acs) > 1:
            raise hgvs.exceptions.HGVSError("Multiple chromosomal alignments for {tx_ac} in {pa}"
                                            "using {am} (likely paralog or pseudoautosomal region)".format(
                                                tx_ac=tx_ac, pa=self.primary_assembly, am=self.src_alt_aln_method))
        if len(alt_acs) == 0:
            raise hgvs.exceptions.HGVSError("No alignments for {tx_ac} in {pa} using {am}".format(
                tx_ac=tx_ac, pa=self.primary_assembly, am=self.src_alt_aln_method))
        return alt_acs[0]       # exactly one remains



if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    hdp = hgvs.dataproviders.uta.connect()
    hp = hgvs.parser.Parser()
    tf = Transformer(hdp)
    evm_g = hgvs.variantmapper.EasyVariantMapper(hdp,alt_aln_method='genebuild')
    evm_s = hgvs.variantmapper.EasyVariantMapper(hdp,alt_aln_method='splign')

    fn = sys.argv[1]
    hgvs_src = open(fn,'r')

    # original enst variants (values) that project to the same genomic hgvs (as key)
    hgvs_g_ensts = collections.defaultdict(lambda: set())

    # derived nm variants (values) for a genomic hgvs (key)
    hgvs_g_nms_tf = collections.defaultdict(lambda: [])
    hgvs_g_nms_evm = collections.defaultdict(lambda: [])

    for hgvs_str in hgvs_src:
        hgvs_str = hgvs_str.strip()

        try:
            assert 'c.' in hgvs_str, "expected a c. variant ("+hgvs_str+")"
            assert hgvs_str.startswith('ENST'), "expected an ENST variant ("+hgvs_str+")"

            var_c = hp.parse_hgvs_variant(hgvs_str.strip())
            var_c.ac = var_c.ac.split('.')[0] # strip version number

            var_g = evm_g.c_to_g(var_c)
            hgvs_g = str(var_g)

            hgvs_g_ensts[hgvs_g].add(hgvs_str)

            if hgvs_g not in hgvs_g_nms_tf:
                mapped_vars = tf.project_variant(var_c)
                if mapped_vars:
                    hgvs_g_nms_tf[hgvs_g] = map(str,mapped_vars)

            if hgvs_g not in hgvs_g_nms_evm:
                mapped_vars = [ evm_g.g_to_c(var_g,ac) for ac in evm_g.relevant_transcripts(var_g) ]
                if mapped_vars:
                    hgvs_g_nms_evm[hgvs_g] = map(str,mapped_vars)

        except (AssertionError,hgvs.exceptions.HGVSError,ometa.runtime.ParseError) as ex:

            logger.error("{hgvs_str}: {e}".format(hgvs_str=hgvs_str, e=re.sub('[\s^]+',' ',str(ex)) ))
            #print("! {hgvs_str}: {e}".format(hgvs_str=hgvs_str, e=re.sub('[\s^]+',' ',str(ex)) ))

    print('\t'.join('hgvs_g   n_enst_vars n_tf_vars n_evm_vars    enst_vars tf_vars evm_vars'.split()))
    for hgvs_g in hgvs_g_ensts:
        enst_vars = hgvs_g_ensts[hgvs_g]
        tf_vars = hgvs_g_nms_tf[hgvs_g]
        evm_vars = hgvs_g_nms_evm[hgvs_g]
        print('\t'.join([hgvs_g,str(len(enst_vars)),str(len(tf_vars)),str(len(evm_vars)),'|'.join(enst_vars),'|'.join(tf_vars),'|'.join(evm_vars)]))



## <LICENSE>
## Copyright 2014 HGVS Contributors (https://bitbucket.org/invitae/hgvs)
## 
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
## 
##     http://www.apache.org/licenses/LICENSE-2.0
## 
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
## </LICENSE>
